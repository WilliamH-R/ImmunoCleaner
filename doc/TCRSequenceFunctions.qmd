---
title: "Exploring CD8+ T-cell Specificities using Single Cell Immune Profiling with an Outlook to Reproducible Bio Data Science"
author: "William Hagedorn-Rasmussen"
format:
  pdf:
    include-in-header:
      text: |
       \usepackage[font=footnotesize,labelfont=bf,textfont=it]{caption}
toc: true
number-sections: true
crossref:
  chapters: true
csl: citation_style.csl
bibliography: bachelor_references.bib
editor: visual
---

{{< pagebreak >}}

# Imports {#sec-Import}

```{r setup}
library(TCRSequenceFunctions)
library(gt)
```

# Introduction {#sec-Intro}

This package, [TCRSequenceFunctions](https://github.com/WilliamH-R/TCRSequenceFunctions), is a collection of functions made for working with data sets from a Single Cell Immune Profiling experiment made by 10x Genomics @10XGenomics2022. There is a total of four data sets which all follow the same general structure. They differ in that, they contain data from each their own respective donor.

The data sets contains binding counts between the donors' library of T-Cell Receptors (TCRs) and a set of peptide-major histocompatibility complexes (pMHCs). The before-mentioned binding counts are so called unique molecular identifier (UMI) counts. For an explanation of all columns see @sec-AppendixA.

In the following sections, each of the functions contained in [TCRSequenceFunctions](https://github.com/WilliamH-R/TCRSequenceFunctions) will be explained, demonstrated and reasoned for. Generally, they can be divided into three types: Cleaning, Augmenting and Modelling where the main goal of the two first is to make the data tidy.

Lastly will be a short section on a Shiny Package, [TCRSequenceShiny](https://github.com/WilliamH-R/TCRSequenceShiny), which utilizes these functions to make a user-friendly interactive interface for data exploration.

# Tidying the data {#sec-TidyData}

The aim of tidying the data is to enable the data handling, and to ensure a reproducible result. Firstly, the data is cleaned e.g. by making sure, all cells only contain one piece of information. Afterwards, some augmented was needed to enable the modelling. This was done by e.g. adding new columns. A wrapper function was used to run all the preparation functions: `run_all_prep()`. This wrapper simply takes one of the raw data files included in the package as input, and pipe it through all the preparation functions, and output tidy data as in @lst-tidydata_pipeline.

``` {#lst-tidydata_pipeline .R lst-cap="How to pipe data through wrapper"}
data_donor_one_raw %>%
  run_all_prep()
```

## Cleaning {#sec-CleaningData}

As mentioned above, cleaning the data is mostly focusing on handling already present data and/or re-structure the data frame. The list of cleaning functions are as follows:

1.  `remove_unnecessary_columns()`
2.  `find_non_promiscuous_split_TCR_sequences()`
3.  `pivot_longer_TCR_sequences()`
4.  `add_chain_ident_remove_prefix()`
5.  `pivot_longer_pMHC()`
6.  `tidy_pMHC_names()`

The first function takes the raw data frame as input, and simply removes the unnecessary columns as these aren't needed. By default, the columns removed are those containing `"_binder"` and the column `"cell_clono_cdr3_nt"`.

`find_non_promiscuous_split_TCR_sequences()`, `pivot_longer_TCR_sequence()` and `add_chain_ident_remove_prefix()` works in close relation with one another. The main purpose is to tidy the TCR-sequences, as to not have cells with multiple pieces of information. @tbl-TCR_sequence_example_before shows three examples as to how these are written. A column is added to indicate a non-promiscuous pair (i.e., a pair with one alpha- and beta chain respectively) and contains the TCR-sequence of said pair. This is done since the sequences of non-promiscuous pairs are needed for modelling in `relevant_binder_frequency_plot()`. The TCR-sequences are then split into new columns, one for each chain. These new columns are then pivot longer into the column `TCR_sequence` by `pivot_longer_TCR_sequence()`. Lastly, a new column is added to indicate chain type, `chain`, and the chain indicator `"TR[A|B]"` is removed. The result can be seen in @tbl-TCR_sequence_example_after.

```{r}
#| echo: false
#| label: tbl-TCR_sequence_example_before
#| tbl-cap: "A snippet of `data_donor_one_raw` to show two examples as to how TCR-sequences are written"

data_donor_one_raw %>% 
  dplyr::slice_head(n = 3) %>%
  dplyr::select(cell_clono_cdr3_aa) %>%
  gt() %>%
  cols_label(
    cell_clono_cdr3_aa = md("**cell_clono_cdr3_aa**")
  ) %>% 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  )
```

```{r}
#| echo: false
#| label: tbl-TCR_sequence_example_after
#| tbl-cap: "A snippet of the output from `find_non_promiscuous_split_TCR_sequences()` to show a tidy version of the TCR-sequences"

data_donor_one_raw %>%
  dplyr::slice_head(n = 3) %>%
  find_non_promiscuous_split_TCR_sequences() %>% 
  pivot_longer_TCR_sequences() %>% 
  add_chain_ident_remove_prefix() %>% 
  dplyr::select(TCR_sequence, chain, non_promiscuous_pair) %>%
  gt() %>%
  cols_label(
    TCR_sequence = md("**TCR_sequence**"),
    chain = md("**chain**"),
    non_promiscuous_pair = md("**non_promiscuous_pair**")
  ) %>% 
  cols_align(
    align = "center",
    columns = non_promiscuous_pair
  )
```

A similar process is applied to all column names which follow the general structure: `"allele_peptide_peptidesource"`. This is done through `pivot_longer_pMHC()` and `tidy_pMHC_names()`. First the names are pivot longer with their associated UMI-counts as values. Here, only non-zero values are kept as they are otherwise irrelevant. The names, now as rows, are made tidy by splitting into three new columns:

1.  `allele`

2.  `peptide`

3.  `peptide_source`

This step is important as to not have multiple pieces of information in one cell, and as they are used for modelling in `summarise_with_filter()`.

## Augmenting {#sec-AugmentingData}

Generally speaking, augmenting the data refers to adding new columns which enable later modelling. In some cases, it makes more sense to do augmenting while cleaning (e.g. `find_non_promiscuous_split_TCR_sequences()`). The list of augmenting functions are as follows:

1.  `add_max_non_specific_binder()`
2.  `evaluate_binder()`
3.  `add_TCR_combination_identifier()`

The first and second function are both required to find the relevant binders. A relevant binder has four requirements which needs to be met:

1.  UMI-count needs to be larger than some threshold
2.  The UMI-count has to be another threshold times higher than the non-specific binder with the highest UMI-count for that barcode
3.  If multiple specificities exist, only use the one with the highest UMI-count
4.  Disregard a cell if it shows specificity towards more than four pMHC

And so, the purpose of the first function is to find the highest UMI-count of all non-specific binders for each barcode. The count is added in a new column called `max_non_specific_binder`. The second function then uses the above mentioned requirements to evaluate all binding events. The evaluation is used in e.g. `relevant_binder_frequency_plot()`. Some examples of evaluation can be seen in @tbl-binder_evaluation.

```{r}
#| echo: false
#| label: tbl-binder_evaluation
#| tbl-cap: "Examples of how different combinations of UMI-count and max_non_specific_binder are evaluated"

data_donor_one_tidy %>% 
  dplyr::group_by(is_binder) %>% 
  dplyr::slice_head(n = 3) %>% 
  dplyr::select(pMHC,
                UMI_count,
                max_non_specific_binder,
                is_binder) %>% 
  gt(rowname_col = "pMHC") %>% 
  cols_label(
    UMI_count = md("**UMI_count**"),
    max_non_specific_binder = md("**max_non_specific_binder**"),
    is_binder = md("**is_binder**")
  ) %>% 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body(
      columns = everything()
    )
  )
```

Lastly, `add_TCR_combination_identifier()` categorizes the TCR-sequence chain combinations for each barcode. I.e. it determines which of the following groups the TCR-sequence for a barcode belongs to:

1.  Containing only one alpha chain and no beta chains
2.  Containing no alpha chain and only one beta chain
3.  Containing one alpha chain and beta chain respectively
4.  Some other combination

This allows for a distribution of the above-mentioned categories to perform a quick check on the data through `alpha_beta_pair_distributions()`. A few examples can be seen in @tbl-chain_categorizing.

```{r}
#| echo: false
#| label: tbl-chain_categorizing
#| tbl-cap: "Examples of how barcodes are categorized depending on their alpha- and beta chain combination"

data_donor_one_tidy %>%
  dplyr::slice_head(n = 11) %>% 
  dplyr::select(barcode,
                chain,
                TCR_combination) %>% 
  gt() %>%
  cols_label(
    barcode = md("**barcode**"),
    chain = md("**chain**"),
    TCR_combination = md("**TCR_combination**")
  ) %>% 
  cols_align(
    align = "center",
    columns = TCR_combination
  )
```

## Change of dimensions

Naturally, the dimensions of all included data sets change after being piped through `run_all_prep()`. @tbl-dimensions shows the dimensions for both the raw and tidy data sets stratified on donor. The number of columns are always reduced to 27, but the number of rows depend on the original number of rows and the data itself.

::: {#tbl-dimensions layout-ncol="2"}
|      **Donor 1**      |          **`raw`**           |          **`tidy`**           |
|:------------------:|:------------------------:|:-------------------------:|
| **Number of columns** | `r ncol(data_donor_one_raw)` | `r ncol(data_donor_one_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_one_raw)` | `r nrow(data_donor_one_tidy)` |

: {#tbl-dimensions_donor_one}

|      **Donor 2**      |          **`raw`**           |          **`tidy`**           |
|:------------------:|:------------------------:|:-------------------------:|
| **Number of columns** | `r ncol(data_donor_two_raw)` | `r ncol(data_donor_two_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_two_raw)` | `r nrow(data_donor_two_tidy)` |

: {#tbl-dimensions_donor_two}

|      **Donor 3**      |           **`raw`**            |           **`tidy`**            |
|:-----------------:|:------------------------:|:-------------------------:|
| **Number of columns** | `r ncol(data_donor_three_raw)` | `r ncol(data_donor_three_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_three_raw)` | `r nrow(data_donor_three_tidy)` |

: {#tbl-dimensions_donor_three}

|      **Donor 4**      |           **`raw`**           |           **`tidy`**           |
|:------------------:|:------------------------:|:-------------------------:|
| **Number of columns** | `r ncol(data_donor_four_raw)` | `r ncol(data_donor_four_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_four_raw)` | `r nrow(data_donor_four_tidy)` |

: {#tbl-dimensions_donor_four}

Dimensions of data sets for **(a)** Donor 1, **(b)** Donor 2, **(c)** Donor 3 and **(d)** Donor 4 before and after being prepared by the wrapper `run_all_prep()`
:::

# Modelling {#sec-ModelData}

All of the tidying done in the above enables the modelling which are described in this section. For each model, a subsection is included to describe the purpose and the output of said models. The list of modeling functions are:

1.  `summarise_with_filter()`
2.  `relevant_binder_frequency_plot()`
3.  `alpha_beta_pair_distributions()`
4.  `alpha_beta_sequence_consistency()`

## `summarise_with_filter()` {#sec-summarise_with_filter}

As input, this function takes a tidy data frame. For each cell - barcode - it counts all of the relevant binding events stratified on a user input. Through its arguments it's possible to decide the stratification as shown in @tbl-summarise_with_filter.

```{r}
#| label: tbl-summarise_with_filter
#| tbl-cap: "Output of the function `summarise_with_filter()`. For each allele and for each peptide a count as noted indicating the number of binding events to cells."

data_donor_one_tidy %>%
  summarise_with_filter(summarise_by = c("allele", "peptide")) %>% 
  gt()
```

# Shiny Integration {#sec-Shiny}

# References {.unnumbered}

# Appendix {#sec-Appendix}

## Appendix A {#sec-AppendixA}
