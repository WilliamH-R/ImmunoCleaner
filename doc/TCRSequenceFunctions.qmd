---
title: "Exploring CD8+ T-cell Specificities using Single Cell Immune Profiling with an Outlook to Reproducible Bio Data Science"
author: "William Hagedorn-Rasmussen"
toc: true
number-sections: true
crossref:
  chapters: true
csl: citation_style.csl
bibliography: bachelor_references.bib
editor: visual
always_allow_html: true
format: html
  #pdf:
   # include-in-header:
    #  text: |
     #  \usepackage[font=footnotesize,labelfont=bf,textfont=it]{caption}
---

{{< pagebreak >}}

# Imports {#sec-Import}

```{r setup}
library(TCRSequenceFunctions)
library(gt)
library(notly)
```

# Introduction {#sec-Intro}

This package, [TCRSequenceFunctions](https://github.com/WilliamH-R/TCRSequenceFunctions), is a collection of functions made for working with data sets from a Single Cell Immune Profiling experiment made by 10x Genomics @10XGenomics2022. There is a total of four data sets which all follow the same general structure. They differ in that, they contain data from each their own respective donor.

The data sets contains binding counts between the donors' library of T-Cell Receptors (TCRs) and a set of peptide-major histocompatibility complexes (pMHCs). The before-mentioned binding counts are so called unique molecular identifier (UMI) counts. For an explanation of all columns see @sec-AppendixA.

In the following sections, each of the functions contained in [TCRSequenceFunctions](https://github.com/WilliamH-R/TCRSequenceFunctions) will be explained, demonstrated and reasoned for. Generally, they can be divided into three types: Cleaning, Augmenting and Modelling where the main goal of the two first is to make the data tidy.

Lastly will be a short section on a Shiny Package, [TCRSequenceShiny](https://github.com/WilliamH-R/TCRSequenceShiny), which utilizes these functions to make a user-friendly interactive interface for data exploration.

# Tidying the data {#sec-TidyData}

The aim of tidying the data is to enable the data handling, and to ensure a reproducible result. Firstly, the data is cleaned e.g. by making sure, all cells only contain one piece of information. Afterwards, some augmented was needed to enable the modelling. This was done by e.g. adding new columns. A wrapper function was used to run all the preparation functions: `run_all_prep()`. This wrapper simply takes one of the raw data files included in the package as input, and pipe it through all the preparation functions, and output tidy data as in @lst-tidydata_pipeline.

``` {#lst-tidydata_pipeline .R lst-cap="How to pipe data through wrapper"}
data_donor_one_raw %>%
  run_all_prep()
```

## Cleaning {#sec-CleaningData}

As mentioned above, cleaning the data is mostly focusing on handling already present data and/or re-structure the data frame. The list of cleaning functions are as follows:

1.  `remove_unnecessary_columns()`
2.  `find_non_promiscuous_split_TCR_sequences()`
3.  `pivot_longer_TCR_sequences()`
4.  `add_chain_ident_remove_prefix()`
5.  `pivot_longer_pMHC()`
6.  `tidy_pMHC_names()`

The first function takes the raw data frame as input, and simply removes the unnecessary columns as these aren't needed. By default, the columns removed are those containing `"_binder"` and the column `"cell_clono_cdr3_nt"`.

`find_non_promiscuous_split_TCR_sequences()`, `pivot_longer_TCR_sequence()` and `add_chain_ident_remove_prefix()` works in close relation with one another. The main purpose is to tidy the TCR-sequences, as to not have cells with multiple pieces of information. @tbl-TCR_sequence_example_before shows three examples as to how these are written. A column is added to indicate a non-promiscuous pair (i.e., a pair with one alpha- and beta chain respectively) and contains the TCR-sequence of said pair. This is done since the sequences of non-promiscuous pairs are needed for modelling in `relevant_binder_frequency_plot()`. The TCR-sequences are then split into new columns, one for each chain. These new columns are then pivot longer into the column `TCR_sequence` by `pivot_longer_TCR_sequence()`. Lastly, a new column is added to indicate chain type, `chain`, and the chain indicator `"TR[A|B]"` is removed. The result can be seen in @tbl-TCR_sequence_example_after.

```{r}
#| echo: false
#| label: tbl-TCR_sequence_example_before
#| tbl-cap: "A snippet of `data_donor_one_raw` to show two examples as to how TCR-sequences are written"

data_donor_one_raw %>% 
  dplyr::slice_head(n = 3) %>%
  dplyr::select(cell_clono_cdr3_aa) %>%
  gt() %>%
  cols_label(
    cell_clono_cdr3_aa = md("**cell_clono_cdr3_aa**")
  ) %>% 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) %>% 
  tab_options(table.width = pct(80))
```

```{r}
#| echo: false
#| label: tbl-TCR_sequence_example_after
#| tbl-cap: "A snippet of the output from `find_non_promiscuous_split_TCR_sequences()` to show a tidy version of the TCR-sequences"

data_donor_one_raw %>%
  dplyr::slice_head(n = 3) %>%
  TCRSequenceFunctions:::find_non_promiscuous_split_TCR_sequences() %>% 
  TCRSequenceFunctions:::pivot_longer_TCR_sequences() %>% 
  TCRSequenceFunctions:::add_chain_ident_remove_prefix() %>% 
  dplyr::select(TCR_sequence, chain, non_promiscuous_pair) %>%
  gt() %>%
  cols_label(
    TCR_sequence = md("**TCR_sequence**"),
    chain = md("**chain**"),
    non_promiscuous_pair = md("**non_promiscuous_pair**")
  ) %>% 
  cols_align(
    align = "center",
    columns = non_promiscuous_pair
  ) %>% 
  tab_options(table.width = pct(80))
```

A similar process is applied to all column names which follow the general structure: `"allele_peptide_peptidesource"`. This is done through `pivot_longer_pMHC()` and `tidy_pMHC_names()`. First the names are pivot longer with their associated UMI-counts as values. Here, only non-zero values are kept as they are otherwise irrelevant. The names, now as rows, are made tidy by splitting into three new columns:

1.  `allele`

2.  `peptide`

3.  `peptide_source`

This step is important as to not have multiple pieces of information in one cell, and as they are used for modelling in `summarise_with_filter()`.

## Augmenting {#sec-AugmentingData}

Generally speaking, augmenting the data refers to adding new columns which enable later modelling. In some cases, it makes more sense to do augmenting while cleaning (e.g. `find_non_promiscuous_split_TCR_sequences()`). The list of augmenting functions are as follows:

1.  `add_max_non_specific_binder()`
2.  `evaluate_binder()`
3.  `add_TCR_combination_identifier()`

The first and second function are both required to find the relevant binders. A relevant binder has four requirements which needs to be met:

1.  UMI-count needs to be larger than some threshold
2.  The UMI-count has to be another threshold times higher than the non-specific binder with the highest UMI-count for that barcode
3.  If multiple specificities exist, only use the one with the highest UMI-count
4.  Disregard a cell if it shows specificity towards more than four pMHC

And so, the purpose of the first function is to find the highest UMI-count of all non-specific binders for each barcode. The count is added in a new column called `max_non_specific_binder`. The second function then uses the above mentioned requirements to evaluate all binding events. The evaluation is used in e.g. `relevant_binder_frequency_plot()`. Some examples of evaluation can be seen in @tbl-binder_evaluation.

```{r}
#| echo: false
#| label: tbl-binder_evaluation
#| tbl-cap: "Examples of how different combinations of UMI-count and max_non_specific_binder are evaluated to either `TRUE` or `FALSE`"

data_donor_one_tidy %>% 
  dplyr::group_by(is_binder) %>% 
  dplyr::slice_head(n = 3) %>% 
  dplyr::select(pMHC,
                UMI_count,
                max_non_specific_binder,
                is_binder) %>% 
  gt(rowname_col = "pMHC") %>% 
  cols_label(
    UMI_count = md("**UMI_count**"),
    max_non_specific_binder = md("**max_non_specific_binder**"),
    is_binder = md("**is_binder**")
  ) %>% 
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body(
      columns = everything()
    )
  )
```

Lastly, `add_TCR_combination_identifier()` categorizes the TCR-sequence chain combinations for each barcode. I.e. it determines which of the following groups the TCR-sequence for a barcode belongs to:

1.  Containing only one alpha chain and no beta chains
2.  Containing no alpha chain and only one beta chain
3.  Containing one alpha chain and beta chain respectively
4.  Some other combination

This allows for a distribution of the above-mentioned categories to perform a quick check on the data through `alpha_beta_pair_distributions()`. A few examples can be seen in @tbl-chain_categorizing.

```{r}
#| echo: false
#| label: tbl-chain_categorizing
#| tbl-cap: "Examples of how barcodes are categorized depending on their alpha- and beta chain combination"

data_donor_one_tidy %>%
  dplyr::slice_head(n = 11) %>% 
  dplyr::select(barcode,
                chain,
                TCR_combination) %>% 
  gt() %>%
  cols_label(
    barcode = md("**barcode**"),
    chain = md("**chain**"),
    TCR_combination = md("**TCR_combination**")
  ) %>% 
  cols_align(
    align = "center",
    columns = TCR_combination
  ) %>% 
  tab_options(table.width = pct(80))
```

## Change of dimensions

Naturally, the dimensions of all included data sets change after being piped through `run_all_prep()`. @tbl-dimensions shows the dimensions for both the raw and tidy data sets stratified on donor. The number of columns are always reduced to 27, but the number of rows depend on the original number of rows and the data itself.

::: {#tbl-dimensions layout-ncol="2"}
|      **Donor 1**      |          **`raw`**           |          **`tidy`**           |
|:---------------------:|:----------------------------:|:-----------------------------:|
| **Number of columns** | `r ncol(data_donor_one_raw)` | `r ncol(data_donor_one_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_one_raw)` | `r nrow(data_donor_one_tidy)` |

: {#tbl-dimensions_donor_one}

|      **Donor 2**      |          **`raw`**           |          **`tidy`**           |
|:---------------------:|:----------------------------:|:-----------------------------:|
| **Number of columns** | `r ncol(data_donor_two_raw)` | `r ncol(data_donor_two_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_two_raw)` | `r nrow(data_donor_two_tidy)` |

: {#tbl-dimensions_donor_two}

|      **Donor 3**      |           **`raw`**            |           **`tidy`**            |
|:---------------------:|:------------------------------:|:-------------------------------:|
| **Number of columns** | `r ncol(data_donor_three_raw)` | `r ncol(data_donor_three_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_three_raw)` | `r nrow(data_donor_three_tidy)` |

: {#tbl-dimensions_donor_three}

|      **Donor 4**      |           **`raw`**           |           **`tidy`**           |
|:---------------------:|:-----------------------------:|:------------------------------:|
| **Number of columns** | `r ncol(data_donor_four_raw)` | `r ncol(data_donor_four_tidy)` |
|  **Number of rows**   | `r nrow(data_donor_four_raw)` | `r nrow(data_donor_four_tidy)` |

: {#tbl-dimensions_donor_four}

Dimensions of data sets for **(a)** Donor 1, **(b)** Donor 2, **(c)** Donor 3 and **(d)** Donor 4 before and after being prepared by the wrapper `run_all_prep()`
:::

# Modelling {#sec-ModelData}

All of the tidying done in the above enables the modelling which are described in this section. For each model, a subsection is included to describe the purpose and the output of said models. The list of modeling functions are:

1.  `summarise_with_filter()`
2.  `relevant_binder_frequency_plot()`
3.  `alpha_beta_pair_distributions()`
4.  `alpha_beta_consistency()`

## `summarise_with_filter()` {#sec-summarise_with_filter}

As input, this function takes a tidy data frame. For each cell - barcode - it counts all of the relevant binding events stratified on a user input. Through its arguments it's possible to decide the stratification as shown in @tbl-summarise_with_filter. From the output it is then apparent, that some alleles and peptides bind more often than others which could prove interesting.

```{r}
#| eval: false

data_donor_one_tidy %>%
  summarise_with_filter(summarise_by = c("allele", "peptide"))
```

```{r}
#| echo: false
#| label: tbl-summarise_with_filter
#| tbl-cap: "Output of the function `summarise_with_filter()`. For each allele and for each peptide a count as noted indicating the number of binding events to cells."

data_donor_one_tidy %>%
  summarise_with_filter(summarise_by = c("allele", "peptide")) %>% 
  dplyr::slice_head(n = 10) %>% 
  gt() %>%
  cols_label(
    allele = md("**allele**"),
    peptide = md("**peptide**"),
    count = md("**count**")
  ) %>% 
  cols_align(
    align = "left",
    columns = count
  ) %>% 
  tab_options(
    heading.border.bottom.width = 10,
    table.width = pct(80)
  )
```

## `relevant_binder_frequency_plot()` {#sec-relevant_binder_frequency_plot}

As the function above, this one also takes a tidy data frame as input. The model counts the number of pMHC which bind to non-promiscuous pairs stratified on barcode. Based om that count, a frequency is calculated showing how often a pMHC bind to a non-promiscuous pair out of all the other pMHC which bind to that exact pair. The output is then a plotly plot (i.e., its interactive) where each dot represent a binding event between pMHC and a non-promiscuous pair. The size of the dot increases with increasing frequency. The axis ticks have been disables due to cluttering, but as mentioned the values can be found by hovering a dot. It is important to mention, that only interactions evaluated to relevant by `evaluate_binder()` is included. Hence, a change of threshold in that function will directly change the output of this function. Furthermore, it is possible to provide the function with a maximum frequency. If one is interested in only ambiguous sequences (i.e., TCR-sequences which bind multiple pMHC), the max frequency should be set to something less than `1`. For a demonstration on how to use the model see @fig-relevant_binder_frequency_plot (will only work properly when rendering in HTML format).

```{r}
#| label: fig-relevant_binder_frequency_plot
#| fig-cap: "Output of the function `relevant_binder_frequency_plot`. Each dot represent a relevant binding between a non-promiscous TCR-sequence and pMHC."
#| layout: [[90]]

data_donor_four_tidy %>%
  relevant_binder_frequency_plot()
```

## `alpha_beta_pair_distribution()` {#sec-alpha_beta_pair_distribution}

As with the other model functions, it takes a tidy data frame as input with the option to only look at distributions for a single pMHC provided through the arguments. From `add_TCR_combination_identifier()` we have the categorization of each cell. By making each barcode unique, and counting number of occurrences for each category, a frequency distribution is obtainable. The output is a bar plot showing exactly that (see @fig-alpha_beta_pair_distribution). It can be used as a quality check of the data.

```{r}
#| label: fig-alpha_beta_pair_distribution
#| fig-cap: "Output of the function `alpha_beta_pair_distribution`. Each bar represent the freuqency of that respective category."

data_donor_four_tidy %>%
  alpha_beta_pair_distribution()
```

## `alpha_beta_consistency()` {#sec-alpha_beta_sequence_consistency}

The input to the function is a tidy data frame from which a frequency to plot is made. The function groups on the barcode, then make TCR-sequences unique, and ungroup again to do a data set wide counting of the number of TCR-sequences. A distinctiveness score is then calculated by comparing the number of completely unique sequences with the total number of TCR-sequences. I.e., a lower score means less distinctive. The calculations are done by stratifying on `chain`. This enables a quick quality check of the data set to whether it follows theory or not. The output is then a bar plot showing the distinctiveness score (See @fig-alpha_beta_consistency).

```{r}
#| label: fig-alpha_beta_consistency
#| fig-cap: "Output of the function `alpha_beta_consistency`. Each bar represent the distinctiveness of that chain type."

data_donor_four_tidy %>%
  alpha_beta_consistency()
```

# Shiny Integration {#sec-Shiny}

# References {.unnumbered}

# Appendix {#sec-Appendix}

## Appendix A {#sec-AppendixA}
